/**
 * Offline level generator (Node).
 * Generates solvable Sokoban levels using reverse pull moves and stores JSON under src/levels/generated/.
 *
 * Usage:
 *   npm run gen:levels -- --want 20 --boxes 3 --reverseSteps 80 --minPush 10 --maxPush 35 --tries 2000 --seed 123
 */
import { mkdirSync, writeFileSync, readdirSync } from "node:fs";
import { join } from "node:path";

import type { LevelJson } from "../src/types";
import { DEFAULT_ARENA, generateOne } from "../src/generator/generate";

// --- tiny CLI parsing (no deps)
function arg(name: string, fallback?: string) {
  const i = process.argv.indexOf(`--${name}`);
  if (i >= 0) return process.argv[i + 1] ?? fallback;
  return fallback;
}
function argNum(name: string, fallback: number) {
  const v = arg(name);
  const n = v == null ? NaN : Number(v);
  return Number.isFinite(n) ? n : fallback;
}

// --- optional deterministic RNG (only works if generator relies on Math.random)
function mulberry32(seed: number) {
  let t = seed >>> 0;
  return () => {
    t += 0x6d2b79f5;
    let r = Math.imul(t ^ (t >>> 15), 1 | t);
    r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
    return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
  };
}
function withSeed(seed: number | undefined, fn: () => Promise<void>) {
  if (seed == null) return fn();

  const prev = Math.random;
  Math.random = mulberry32(seed);
  return fn().finally(() => {
    Math.random = prev;
  });
}

async function main() {
  const outDir = join(process.cwd(), "src/levels/generated");
  mkdirSync(outDir, { recursive: true });

  // knobs
  const want = argNum("want", 20);
  const tries = argNum("tries", 2000);
  const boxCount = argNum("boxes", 3);
  const reverseSteps = argNum("reverseSteps", 80);
  const minPush = argNum("minPush", 10);
  const maxPush = argNum("maxPush", 35);
  const seedStr = arg("seed");
  const seed = seedStr != null ? Number(seedStr) : undefined;

  const targetPushRange: [number, number] = [minPush, maxPush];

  // avoid overwriting if folder already has files
  const existingIds = new Set(
    readdirSync(outDir)
      .filter((f) => f.endsWith(".json"))
      .map((f) => f.replace(/\.json$/, "")),
  );

  const madeIds = new Set<string>();
  let made = 0;

  for (let i = 0; i < tries && made < want; i++) {
    const g = await generateOne(
      DEFAULT_ARENA as LevelJson,
      boxCount,
      reverseSteps,
      targetPushRange,
    );
    if (!g) continue;

    const id = g.level.id;
    if (existingIds.has(id) || madeIds.has(id)) continue;

    const filename = join(outDir, `${id}.json`);
    writeFileSync(filename, JSON.stringify(g.level, null, 2), "utf-8");
    madeIds.add(id);
    made++;
    console.log(`Generated: ${id}  pushes=${g.pushes}`);
  }

  console.log(`Done. Generated ${made}/${want} levels in ${outDir}`);

  // Generate a TS barrel file so your UI can import easily.
  // This avoids manually editing src/levels/index.ts for each file.
  const indexPath = join(outDir, "index.ts");
  const imports = [...madeIds]
    .sort()
    .map((id, k) => `import L${k} from "./${id}.json";`)
    .join("\n");
  const arr = [...madeIds]
    .sort()
    .map((_, k) => `L${k}`)
    .join(", ");

  writeFileSync(
    indexPath,
    `/* auto-generated by gen:levels */\n${imports}\n\nexport const generatedLevels = [${arr}] as const;\n`,
    "utf-8",
  );

  console.log(`Wrote: ${indexPath}`);
  console.log(
    `Now in src/levels/index.ts you can:\n  import { generatedLevels } from "./generated";\n  // and merge into your level list`,
  );

  // If we failed to make enough, exit non-zero (useful in CI).
  if (made < want) {
    console.error(
      `Warning: only generated ${made}/${want}. Try increasing --tries or relaxing constraints.`,
    );
    process.exitCode = 2;
  }
}

withSeed(
  (() => {
    const seedStr = arg("seed");
    return seedStr != null && Number.isFinite(Number(seedStr))
      ? Number(seedStr)
      : undefined;
  })(),
  main,
).catch((e) => {
  console.error(e);
  process.exit(1);
});
